<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cucumber Rust Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User guide for Cucumber Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="writing/index.html"><strong aria-hidden="true">3.</strong> Writing tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing/capturing.html"><strong aria-hidden="true">3.1.</strong> Capturing and variation</a></li><li class="chapter-item expanded "><a href="writing/asserting.html"><strong aria-hidden="true">3.2.</strong> Asserting</a></li><li class="chapter-item expanded "><a href="writing/data_tables.html"><strong aria-hidden="true">3.3.</strong> Data tables</a></li><li class="chapter-item expanded "><a href="writing/doc_strings.html"><strong aria-hidden="true">3.4.</strong> Doc strings</a></li><li class="chapter-item expanded "><a href="writing/rule.html"><strong aria-hidden="true">3.5.</strong> Rule keyword</a></li><li class="chapter-item expanded "><a href="writing/background.html"><strong aria-hidden="true">3.6.</strong> Background keyword</a></li><li class="chapter-item expanded "><a href="writing/scenario_outline.html"><strong aria-hidden="true">3.7.</strong> Scenario Outline keyword</a></li><li class="chapter-item expanded "><a href="writing/hooks.html"><strong aria-hidden="true">3.8.</strong> Scenario hooks</a></li><li class="chapter-item expanded "><a href="writing/languages.html"><strong aria-hidden="true">3.9.</strong> Spoken languages</a></li><li class="chapter-item expanded "><a href="writing/tags.html"><strong aria-hidden="true">3.10.</strong> Tags</a></li><li class="chapter-item expanded "><a href="writing/modules.html"><strong aria-hidden="true">3.11.</strong> Modules organization</a></li></ol></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">4.</strong> CLI (command-line interface)</a></li><li class="chapter-item expanded "><a href="output/index.html"><strong aria-hidden="true">5.</strong> Output</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="output/terminal.html"><strong aria-hidden="true">5.1.</strong> Terminal</a></li><li class="chapter-item expanded "><a href="output/junit.html"><strong aria-hidden="true">5.2.</strong> JUnit XML report</a></li><li class="chapter-item expanded "><a href="output/json.html"><strong aria-hidden="true">5.3.</strong> Cucumber JSON format</a></li><li class="chapter-item expanded "><a href="output/multiple.html"><strong aria-hidden="true">5.4.</strong> Multiple outputs</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">6.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/parser.html"><strong aria-hidden="true">6.1.</strong> Custom Parser</a></li><li class="chapter-item expanded "><a href="architecture/runner.html"><strong aria-hidden="true">6.2.</strong> Custom Runner</a></li><li class="chapter-item expanded "><a href="architecture/writer.html"><strong aria-hidden="true">6.3.</strong> Custom Writer</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cucumber Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://cucumber.io">Cucumber</a> is a specification for running tests in a <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> (behavior-driven development) style workflow. </p>
<p>It assumes involvement of non-technical members on a project and as such provides a human-readable syntax for the definition of features, via the language <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a>. A typical feature could look something like this:</p>
<pre><code class="language-gherkin">Feature: Eating too much cucumbers may not be good for you
    
  Scenario: Eating a few isn't a problem
    Given Alice is hungry
    When she eats 3 cucumbers
    Then she is full
</code></pre>
<p>These features are agnostic to the implementation, the only requirement is that they follow the expected format of phrases followed by the keywords (<code>Given</code>, <code>When</code>, <code>Then</code>). <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a> offers support for <a href="https://cucumber.io/docs/gherkin/languages">languages other than English</a>, as well.</p>
<p><a href="https://cucumber.io">Cucumber</a> implementations then simply hook into these keywords and execute the logic corresponding to the keywords. <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate is one of such implementations and is the subject of this book.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World {
</span><span class="boring">    user: Option&lt;String&gt;,
</span><span class="boring">    capacity: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(Self { user: None, capacity: 0 })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(expr = &quot;{word} is hungry&quot;)] // Cucumber Expression
async fn someone_is_hungry(w: &amp;mut World, user: String) {
    sleep(Duration::from_secs(2)).await;
    
    w.user = Some(user);
}

#[when(regex = r&quot;^(?:he|she|they) eats? (\d+) cucumbers?$&quot;)]
async fn eat_cucumbers(w: &amp;mut World, count: usize) {
    sleep(Duration::from_secs(2)).await;

    w.capacity += count;
    
    assert!(w.capacity &lt; 4, &quot;{} exploded!&quot;, w.user.as_ref().unwrap());
}

#[then(&quot;she is full&quot;)]
async fn is_full(w: &amp;mut World) {
    sleep(Duration::from_secs(2)).await;

    assert_eq!(w.capacity, 3, &quot;{} isn't full!&quot;, w.user.as_ref().unwrap());
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    World::run(&quot;/tests/features/readme&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="rec/readme.gif" alt="record" /></p>
<p>Since the goal is the testing of externally identifiable behavior of some feature, it would be a misnomer to use <a href="https://cucumber.io">Cucumber</a> to test specific private aspects or isolated modules. <a href="https://cucumber.io">Cucumber</a> tests are more likely to take the form of integration, functional or E2E testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Adding <a href="https://cucumber.io">Cucumber</a> to a project requires some groundwork. <a href="https://cucumber.io">Cucumber</a> tests are run along with other tests via <code>cargo test</code>, but rely on <code>.feature</code> files corresponding to the given test, as well as a set of <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matchers (described in code) corresponding to the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s in those <code>.feature</code> files.</p>
<p>To start, let's create a directory called <code>tests/</code> in the root of the project and add a file to represent the test target (in this walkthrough it's <code>example.rs</code>).</p>
<p>Add this to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
async-trait = &quot;0.1&quot;
cucumber = &quot;0.11&quot;
futures = &quot;0.3&quot;

[[test]]
name = &quot;example&quot; # this should be the same as the filename of your test target
harness = false  # allows Cucumber to print output instead of libtest
</code></pre>
<p>At this point, while it won't do anything, it should successfully run <code>cargo test --test example</code> without errors, as long as the <code>example.rs</code> file has at least a <code>main()</code> function defined.</p>
<p>Now, let's create a directory to store <code>.feature</code> files somewhere in the project (in this walkthrough it's <code>tests/features/book/</code> directory), and put a <code>.feature</code> file there (such as <code>animal.feature</code>). It should contain a <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a> spec for the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> we want to test. Here's a very simple example:</p>
<pre><code class="language-gherkin">Feature: Animal feature

  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p>To relate the text of the <code>.feature</code> file with the actual tests we would need a <code>World</code> object, holding a state that is newly created for each <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> and is changing as <a href="https://cucumber.io">Cucumber</a> goes through each <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> of that <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>. The basic requirement for a <code>World</code> object is to provide a <code>new()</code> function.</p>
<p>To enable testing of our <code>animal.feature</code>, let's add this code to <code>example.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::Infallible;

use async_trait::async_trait;
use cucumber::{given, World, WorldInit};

// These `Cat` definitions would normally be inside your project's code, 
// not test code, but we create them here for the show case.
#[derive(Debug)]
struct Cat {
    pub hungry: bool,
}

impl Cat {
    fn feed(&amp;mut self) {
        self.hungry = false;
    }
}

// `World` is your shared, likely mutable state.
#[derive(Debug, WorldInit)]
pub struct AnimalWorld {
    cat: Cat,
}

// `World` needs to be implemented, so Cucumber knows how to construct it
// for each scenario.
#[async_trait(?Send)]
impl World for AnimalWorld {
    // We do require some error type.
    type Error = Infallible;

    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
        Ok(Self {
            cat: Cat { hungry: false },
        })
    }
}

// Steps are defined with `given`, `when` and `then` attributes.
#[given(&quot;a hungry cat&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld) {
    world.cat.hungry = true;
}

// This runs before everything else, so you can setup things here.
fn main() {
    // You may choose any executor you like (`tokio`, `async-std`, etc.).
    // You may even have an `async` main, it doesn't matter. The point is that
    // Cucumber is composable. :)
    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book&quot;));
}
</code></pre></pre>
<p>If we run this, we should see an output like this:<br />
<img src="rec/quickstart_simple_1.gif" alt="record" /></p>
<p>A checkmark <code>âœ”</code> next to the <code>Given a hungry cat</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> means that it has been matched, executed and passed.</p>
<p>But then, for the next <code>When I feed the cat</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> there is a question mark <code>?</code>, meaning that we have nothing in our tests matching this sentence. The remaining <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s in the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> are not looked and run at all, since they depend on the skipped one.</p>
<p>There are 3 types of <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s:</p>
<ul>
<li><code>given</code>: for defining <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> starting conditions and often initializing the data in the <code>World</code>;</li>
<li><code>when</code>: for events or actions triggering the tested changes in the <code>World</code> representing the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>;</li>
<li><code>then</code>: to validate that the <code>World</code> has changed in the way expected by the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>.</li>
</ul>
<p>These various <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching functions are executed to transform the <code>World</code>. As such, mutable reference to the world must always be passed in. The <code>Step</code> itself is also made available.</p>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://cucumber.io/docs/gherkin/reference#steps">Unlike official Cucumber implementation</a> the <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate makes explicit separation between <code>given</code>, <code>when</code> and <code>then</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s. This allows to prevent ambiguity problems when running tests (i.e. to avoid accidental uses of a <code>then</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> as a <code>given</code> one). To remain compliant with existing <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s abusing this, it will be enough to place multiple attributes on the same <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function.</p>
</blockquote>
<p>We can add a <code>when</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matcher:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(&quot;a hungry cat&quot;)]
</span><span class="boring">fn hungry_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.hungry = true;
</span><span class="boring">}
</span><span class="boring">
</span>// Don't forget to additionally `use cucumber::when;`.

#[when(&quot;I feed the cat&quot;)]
fn feed_cat(world: &amp;mut AnimalWorld) {
    world.cat.feed();
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book/quickstart/simple.feature&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<p>Once we run the tests again, we see that two lines are green now and the next one is marked as not yet implemented:<br />
<img src="rec/quickstart_simple_2.gif" alt="record" /></p>
<p>Finally, how do we check our result? We expect that this will cause some change in the cat and that the cat will no longer be hungry since it has been fed. The <code>then</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matcher follows to assert this, as our <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a> says:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(&quot;a hungry cat&quot;)]
</span><span class="boring">fn hungry_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.hungry = true;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span>// Don't forget to additionally `use cucumber::then;`.

#[then(&quot;the cat is not hungry&quot;)]
fn cat_is_fed(world: &amp;mut AnimalWorld) {
    assert!(!world.cat.hungry);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book/quickstart/simple.feature&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<p>Once we run the tests, now we see all steps being accounted for and the whole <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> passing:<br />
<img src="rec/quickstart_simple_3.gif" alt="record" /></p>
<blockquote>
<p><strong>TIP</strong>: In addition to assertions, we may also return a <code>Result&lt;()&gt;</code> from a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function. Returning <code>Err</code> will cause the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> to fail. This lets using the <code>?</code> operator for more concise step implementations just like in <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#tests-and-">unit tests</a>.</p>
</blockquote>
<p>To assure that assertion is indeed happening, let's reverse it temporarily:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    // We require some error type
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(&quot;a hungry cat&quot;)]
</span><span class="boring">fn hungry_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.hungry = true;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span>#[then(&quot;the cat is not hungry&quot;)]
fn cat_is_fed(world: &amp;mut AnimalWorld) {
    assert!(world.cat.hungry);
}
<span class="boring">fn main() {
</span><span class="boring">    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book/quickstart/simple.feature&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<p>And see the test failing:<br />
<img src="rec/quickstart_simple_fail.gif" alt="record" /></p>
<blockquote>
<p><strong>TIP</strong>: By default, unlike <a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html#test-options">unit tests</a>, failed <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s don't terminate the execution instantly, and the whole test suite is executed regardless of them. Use <code>--fail-fast</code> <a href="cli.html">CLI</a> option to stop execution on first failure.</p>
</blockquote>
<p>What if we also want to validate that even if the cat was never hungry to begin with, it won't end up hungry after it was fed? So, we may add an another <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> that looks quite similar:</p>
<pre><code class="language-gherkin">Feature: Animal feature

  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  Scenario: If we feed a satiated cat it will not become hungry
    Given a satiated cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p>The only thing that is different is the <code>Given</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>. But we don't have to write a new matcher here! We can leverage <a href="https://docs.rs/regex"><code>regex</code></a> support:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    match state.as_str() {
        &quot;hungry&quot; =&gt;  world.cat.hungry = true,
        &quot;satiated&quot; =&gt;  world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}
<span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book/quickstart/concurrent.feature&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: We surround the regex with <code>^..$</code> to ensure an <strong>exact</strong> match. This is much more useful when adding more and more <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s, so they won't accidentally interfere with each other.</p>
</blockquote>
<p><a href="https://cucumber.io">Cucumber</a> will reuse these <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matchers:<br />
<img src="rec/quickstart_concurrent_sync.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Captured values are <strong>bold</strong> to indicate which part of a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> is actually captured.</p>
</blockquote>
<p>Alternatively, we also may use <a href="https://cucumber.github.io/cucumber-expressions">Cucumber Expressions</a> for the same purpose (less powerful, but much more readable):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(expr = &quot;a {word} cat&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    match state.as_str() {
        &quot;hungry&quot; =&gt;  world.cat.hungry = true,
        &quot;satiated&quot; =&gt;  world.cat.hungry = false,
        s =&gt; panic!(&quot;expected 'hungry' or 'satiated', found: {}&quot;, s),
    }
}
<span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    futures::executor::block_on(AnimalWorld::run(&quot;/tests/features/book/quickstart/simple.feature&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<p>A contrived example, but it demonstrates that <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s can be reused as long as they are sufficiently precise in both their description and implementation. If, for example, the wording for our <code>Then</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> was <code>The cat is no longer hungry</code>, it would imply something about the expected initial state, when that is not the purpose of a <code>Then</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>, but rather of the <code>Given</code> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>.</p>
<h2 id="asyncness"><a class="header" href="#asyncness">Asyncness</a></h2>
<p><code>async</code> execution is supported naturally.</p>
<p>Let's switch our runtime to <code>tokio</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
async-trait = &quot;0.1&quot;
cucumber = &quot;0.11&quot;
tokio = { version = &quot;1.10&quot;, features = [&quot;macros&quot;, &quot;rt-multi-thread&quot;, &quot;time&quot;] }

[[test]]
name = &quot;example&quot; # this should be the same as the filename of your test target
harness = false  # allows Cucumber to print output instead of libtest
</code></pre>
<p>And, simply <code>sleep</code> on each <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> to test the <code>async</code> support (in the real world, of course, there will be web/database requests, etc.):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    sleep(Duration::from_secs(2)).await;

    match state.as_str() {
        &quot;hungry&quot; =&gt; world.cat.hungry = true,
        &quot;satiated&quot; =&gt; world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}

#[when(&quot;I feed the cat&quot;)]
async fn feed_cat(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    world.cat.feed();
}

#[then(&quot;the cat is not hungry&quot;)]
async fn cat_is_fed(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    assert!(!world.cat.hungry);
}

#[tokio::main]
async fn main() {
    AnimalWorld::run(&quot;/tests/features/book/quickstart&quot;).await;
}
</code></pre></pre>
<p><img src="rec/quickstart_concurrent_async.gif" alt="record" /></p>
<p>Hm, it looks like the runtime waited only for the first <code>Feature</code>, while the second was printed instantly. What's going on? ðŸ¤”</p>
<p>By default, <a href="https://cucumber.io">Cucumber</a> executes <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s <a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrently</a>! That means that runtime actually did wait for all the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s, but overlapped! This allows us to execute tests much faster!</p>
<p>If for some reason we don't want to run <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s concurrently, we may use <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> on them:</p>
<pre><code class="language-gherkin">Feature: Animal feature

  @serial
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  @serial
  Scenario: If we feed a satiated cat it will not become hungry
    Given a satiated cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p><img src="rec/quickstart_serial.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Any <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> marked with <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> will be executed in isolation, ensuring that there are no other <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s running concurrently at the moment.</p>
</blockquote>
<blockquote>
<p><strong>TIP</strong>: To run the whole test suite serially, consider using <code>--concurrency=1</code> <a href="cli.html">CLI</a> option, rather than marking evey single <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a> with a <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h1>
<p>This chapter contains overview and examples of some <a href="https://cucumber.io">Cucumber</a> and <a href="https://cucumber.io/docs/gherkin">Gherkin</a> features allowing to write tests in a more idiomatic and maintainable way.</p>
<p>Also, it's worth to become familiar with <a href="https://cucumber.io/docs/gherkin/reference">Gherkin language</a>.</p>
<ol>
<li><a href="writing/capturing.html">Capturing and variation</a></li>
<li><a href="writing/asserting.html">Asserting</a></li>
<li><a href="writing/data_tables.html">Data tables</a></li>
<li><a href="writing/doc_strings.html">Doc strings</a></li>
<li><a href="writing/rule.html"><code>Rule</code> keyword</a></li>
<li><a href="writing/background.html"><code>Background</code> keyword</a></li>
<li><a href="writing/scenario_outline.html"><code>Scenario Outline</code> keyword</a></li>
<li><a href="writing/hooks.html">Scenario hooks</a></li>
<li><a href="writing/languages.html">Spoken languages</a></li>
<li><a href="writing/tags.html">Tags</a></li>
<li><a href="writing/modules.html">Modules organization</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturing-and-variation"><a class="header" href="#capturing-and-variation">Capturing and variation</a></h1>
<p>Using <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> or <a href="https://cucumber.github.io/cucumber-expressions">Cucumber Expressions</a> for our <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching functions allows us:</p>
<ul>
<li>to capture values from a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> and use them inside a test function;</li>
<li>to match variations of a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> with a single test function.</li>
</ul>
<h2 id="regular-expressions"><a class="header" href="#regular-expressions">Regular expressions</a></h2>
<p>Using a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a> for a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function is possible with <code>regex =</code> attribute modifier:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    match state.as_str() {
        &quot;hungry&quot; =&gt;  world.cat.hungry = true,
        &quot;satiated&quot; =&gt;  world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}

#[when(regex = r&quot;^I feed the cat \d+ times?$&quot;)]
fn feed_cat(world: &amp;mut AnimalWorld) {
    world.cat.feed();
}
<span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/capturing.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: We surround the <a href="https://en.wikipedia.org/wiki/Regular_expression">regex</a> with <code>^..$</code> to ensure an <strong>exact</strong> match. This is much more useful when adding more and more <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s, so they won't accidentally interfere with each other.</p>
</blockquote>
<p><img src="writing/../rec/writing_capturing.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Captured values are <strong>bold</strong> to indicate which part of a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> is actually captured.</p>
</blockquote>
<h2 id="fromstr-arguments"><a class="header" href="#fromstr-arguments"><code>FromStr</code> arguments</a></h2>
<p>For matching a captured value we are not restricted to use only <code>String</code>. In fact, any type implementing a <a href="https://doc.rust-lang.org/stable/std/str/trait.FromStr.html"><code>FromStr</code></a> trait can be used as a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> function argument (including primitive types).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, str::FromStr};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: State,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = State::Satiated;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug)]
enum State {
    Hungry,
    Satiated,
}

impl FromStr for State {
    type Err = String;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;hungry&quot; =&gt; Self::Hungry,
            &quot;satiated&quot; =&gt; Self::Satiated,
            invalid =&gt; return Err(format!(&quot;Invalid `State`: {invalid}&quot;)),
        })
    }
}
<span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat {
</span><span class="boring">                hungry: State::Satiated,
</span><span class="boring">            },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: State) {
    world.cat.hungry = state;
}

#[when(regex = r&quot;^I feed the cat (\d+) times?$&quot;)]
fn feed_cat(world: &amp;mut AnimalWorld, times: u8) {
    for _ in 0..times {
        world.cat.feed();
    }
}
<span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(matches!(world.cat.hungry, State::Satiated));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/capturing.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_capturing_both.gif" alt="record" /></p>
<h2 id="cucumber-expressions"><a class="header" href="#cucumber-expressions">Cucumber Expressions</a></h2>
<p>Alternatively, a <a href="https://cucumber.github.io/cucumber-expressions">Cucumber Expression</a> may be used to capture values. This is possible with <code>expr =</code> attribute modifier and <a href="https://github.com/cucumber/cucumber-expressions#parameter-types">parameters</a> usage:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, str::FromStr};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: State,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = State::Satiated;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum State {
</span><span class="boring">    Hungry,
</span><span class="boring">    Satiated,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl FromStr for State {
</span><span class="boring">    type Err = String;
</span><span class="boring">
</span><span class="boring">    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
</span><span class="boring">        Ok(match s {
</span><span class="boring">            &quot;hungry&quot; =&gt; Self::Hungry,
</span><span class="boring">            &quot;satiated&quot; =&gt; Self::Satiated,
</span><span class="boring">            invalid =&gt; return Err(format!(&quot;Invalid `State`: {invalid}&quot;)),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat {
</span><span class="boring">                hungry: State::Satiated,
</span><span class="boring">            },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(expr = &quot;a {word} cat&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: State) {
    world.cat.hungry = state;
}

#[when(expr = &quot;I feed the cat {int} time(s)&quot;)]
fn feed_cat(world: &amp;mut AnimalWorld, times: u8) {
    for _ in 0..times {
        world.cat.feed();
    }
}
<span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(matches!(world.cat.hungry, State::Satiated));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/capturing.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><a href="https://cucumber.github.io/cucumber-expressions">Cucumber Expressions</a> are less powerful in terms of parsing and capturing values, but are much more readable than <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>, so it's worth to prefer using them for simple matching.</p>
<p><img src="writing/../rec/writing_capturing_both.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Captured <a href="https://github.com/cucumber/cucumber-expressions#parameter-types">parameters</a> are <strong>bold</strong> to indicate which part of a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> is actually captured.</p>
</blockquote>
<h3 id="custom-parameters"><a class="header" href="#custom-parameters">Custom <a href="https://github.com/cucumber/cucumber-expressions#parameter-types">parameters</a></a></h3>
<p>Another useful advantage of using <a href="https://cucumber.github.io/cucumber-expressions">Cucumber Expressions</a> is an ability to declare and reuse  <a href="https://github.com/cucumber/cucumber-expressions#custom-parameter-types">custom parameters</a> in addition to <a href="https://github.com/cucumber/cucumber-expressions#parameter-types">default ones</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, str::FromStr};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span>use cucumber::Parameter;

<span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: State,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = State::Satiated;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug, Parameter)]
// NOTE: `name` is optional, by default the lowercased type name is implied.
#[param(name = &quot;hungriness&quot;, regex = &quot;hungry|satiated&quot;)]
enum State {
    Hungry,
    Satiated,
}

// NOTE: `Parameter` requires `FromStr` being implemented.
impl FromStr for State {
    type Err = String;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;hungry&quot; =&gt; Self::Hungry,
            &quot;satiated&quot; =&gt; Self::Satiated,
            invalid =&gt; return Err(format!(&quot;Invalid `State`: {invalid}&quot;)),
        })
    }
}
<span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat {
</span><span class="boring">                hungry: State::Satiated,
</span><span class="boring">            },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[given(expr = &quot;a {hungriness} cat&quot;)]
fn hungry_cat(world: &amp;mut AnimalWorld, state: State) {
    world.cat.hungry = state;
}
<span class="boring">
</span><span class="boring">#[when(expr = &quot;I feed the cat {int} time(s)&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld, times: u8) {
</span><span class="boring">    for _ in 0..times {
</span><span class="boring">        world.cat.feed();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(matches!(world.cat.hungry, State::Satiated));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/capturing.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: Using <a href="https://github.com/cucumber/cucumber-expressions#custom-parameter-types">custom parameters</a> allows declaring and reusing complicated and precise matches without a need to repeat them in different <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching functions.</p>
</blockquote>
<p><img src="writing/../rec/writing_capturing_both.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asserting"><a class="header" href="#asserting">Asserting</a></h1>
<p>There are two ways of doing <a href="https://en.wikipedia.org/wiki/Assertion_(software_development)">assertion</a>s in a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function: </p>
<ul>
<li><a href="writing/asserting.html#panic">throwing a panic</a>;</li>
<li><a href="writing/asserting.html#result-and-">returning an error</a>.</li>
</ul>
<h2 id="panic"><a class="header" href="#panic">Panic</a></h2>
<p>Throwing a panic in a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function makes the appropriate <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> failed:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt;  world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt;  world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span>#[then(&quot;the cat is not hungry&quot;)]
fn cat_is_fed(_: &amp;mut AnimalWorld) {
    panic!(&quot;Cats are always hungry!&quot;)
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::cucumber()
</span><span class="boring">        .run_and_exit(&quot;/tests/features/book/writing/asserting.feature&quot;)
</span><span class="boring">        .await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_asserting_panic.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Failed <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> prints its location in a <code>.feature</code> file and the captured <a href="https://en.wikipedia.org/wiki/Assertion_(software_development)">assertion</a> message.</p>
</blockquote>
<blockquote>
<p><strong>TIP</strong>: To additionally print the state of the <code>World</code> at the moment of failure, increase output verbosity via <code>-vv</code> <a href="writing/../cli.html">CLI</a> option.</p>
</blockquote>
<blockquote>
<p><strong>TIP</strong>: By default, unlike <a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html#test-options">unit tests</a>, failed <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s don't terminate the execution instantly, and the whole test suite is executed regardless of them. Use <code>--fail-fast</code> <a href="writing/../cli.html">CLI</a> option to stop execution on first failure.</p>
</blockquote>
<h2 id="result-and-"><a class="header" href="#result-and-"><code>Result</code> and <code>?</code></a></h2>
<p>Similarly to <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#tests-and-">using the <code>?</code> operator in Rust tests</a>, we may also return a <code>Result&lt;()&gt;</code> from a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function, so returning an <code>Err</code> will cause the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> to fail (anything implementing <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Display.html"><code>Display</code></a> is sufficient).</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt;  world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt;  world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[when(&quot;I feed the cat&quot;)]
fn feed_cat(_: &amp;mut AnimalWorld) {}

#[then(&quot;the cat is not hungry&quot;)]
fn cat_is_fed(world: &amp;mut AnimalWorld) -&gt; Result&lt;(), &amp;'static str&gt; {
    (!world.cat.hungry).then(|| ()).ok_or(&quot;Cat is still hungry!&quot;)
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::cucumber()
</span><span class="boring">        .run_and_exit(&quot;/tests/features/book/writing/asserting.feature&quot;)
</span><span class="boring">        .await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_asserting_result.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-tables"><a class="header" href="#data-tables">Data tables</a></h1>
<p><a href="https://cucumber.io/docs/gherkin/reference#data-tables">Data tables</a> represent a handy way for passing a list of values to a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> definition (and so, to a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function). This is a vital ability for writing <a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">table driven tests</a>.</p>
<pre><code class="language-gherkin">Feature: Animal feature

  Scenario: If we feed a hungry animal it will no longer be hungry
    Given a hungry animal
      | animal |
      | cat    |
      | dog    |
      | ðŸ¦€     |
    When I feed the animal multiple times
      | animal | times |
      | cat    | 2     |
      | dog    | 3     |
      | ðŸ¦€     | 4     |
    Then the animal is not hungry
</code></pre>
<p>Data, declared in the <a href="https://cucumber.io/docs/gherkin/reference#data-tables">table</a>, may be accessed via <a href="https://docs.rs/gherkin/*/gherkin/struct.Step.html"><code>Step</code></a> argument:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{collections::HashMap, convert::Infallible};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span>use cucumber::{gherkin::Step, given, then, when, World, WorldInit};

#[given(regex = r&quot;^a (hungry|satiated) animal$&quot;)]
async fn hungry_animal(world: &amp;mut AnimalWorld, step: &amp;Step, state: String) {
    let state = match state.as_str() {
        &quot;hungry&quot; =&gt; true,
        &quot;satiated&quot; =&gt; false,
        _ =&gt; unreachable!(),
    };

    if let Some(table) = step.table.as_ref() {
        for row in table.rows.iter().skip(1) { // NOTE: skip header
            let animal = &amp;row[0];

            world
                .animals
                .entry(animal.clone())
                .or_insert(Animal::default())
                .hungry = state;
        }
    }
}

#[when(&quot;I feed the animal multiple times&quot;)]
async fn feed_animal(world: &amp;mut AnimalWorld, step: &amp;Step) {
    if let Some(table) = step.table.as_ref() {
        for row in table.rows.iter().skip(1) { // NOTE: skip header
            let animal = &amp;row[0];
            let times = row[1].parse::&lt;usize&gt;().unwrap();

            for _ in 0..times {
                world.animals.get_mut(animal).map(Animal::feed);
            }
        }
    }
}

#[then(&quot;the animal is not hungry&quot;)]
async fn animal_is_fed(world: &amp;mut AnimalWorld) {
    for animal in world.animals.values() {
        assert!(!animal.hungry);
    }
}

#[derive(Debug, Default)]
struct Animal {
    pub hungry: bool,
}

impl Animal {
    fn feed(&amp;mut self) {
        self.hungry = false;
    }
}

#[derive(Debug, WorldInit)]
pub struct AnimalWorld {
    animals: HashMap&lt;String, Animal&gt;,
}

#[async_trait(?Send)]
impl World for AnimalWorld {
    type Error = Infallible;

    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
        Ok(Self {
            animals: HashMap::new(),
        })
    }
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/data_tables.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: The whole table data is processed during a single <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> run.</p>
</blockquote>
<p><img src="writing/../rec/writing_data_tables.gif" alt="record" /></p>
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<ul>
<li>To use a newline character in a table cell, write it as <code>\n</code>. </li>
<li>To use a <code>|</code> as a part in a table cell, escape it as <code>\|</code>. </li>
<li>And finally, to use a <code>\</code>, escape it as <code>\\</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doc-strings"><a class="header" href="#doc-strings">Doc strings</a></h1>
<p><a href="https://cucumber.io/docs/gherkin/reference#doc-strings">Doc strings</a> provide an ability to pass a large piece of text to a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> definition (and so, to a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function).</p>
<p>The text should be offset by delimiters consisting of three double-quote marks <code>&quot;&quot;&quot;</code> on lines of their own:</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
      &quot;&quot;&quot;
      A hungry cat called Felix is rescued from a Whiskas tin in a calamitous 
      mash-up of cat food brands.
      &quot;&quot;&quot;
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Indentation of the opening <code>&quot;&quot;&quot;</code> is unimportant, although the common practice is to indent them. The indentation inside the triple quotes, however, is significant. Each line of the <a href="https://cucumber.io/docs/gherkin/reference#doc-strings">doc string</a> will be dedented according to the opening <code>&quot;&quot;&quot;</code>. Indentation beyond the column of the opening <code>&quot;&quot;&quot;</code> will therefore be preserved.</p>
</blockquote>
<p><a href="https://cucumber.io/docs/gherkin/reference#doc-strings">Doc strings</a> also support using three backticks <code>```</code> as the delimiter, which might be familiar for those used to writing with <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>:</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry Leo it will no longer be hungry
    Given a hungry cat
      ```
      A hungry cat called Leo is rescued from a Whiskas tin in a calamitous
      mash-up of cat food brands.
      ```
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p>Itâ€™s also possible to annotate the <a href="https://cucumber.io/docs/gherkin/reference#doc-strings">doc string</a> with the type of content it contains, as follows:</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry Simba it will no longer be hungry
    Given a hungry cat
      &quot;&quot;&quot;markdown
      About Simba
      ===========
      A hungry cat called Simba is rescued from a Whiskas tin in a calamitous
      mash-up of cat food brands.
      &quot;&quot;&quot;
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Whilst <a href="https://docs.rs/cucumber"><code>cucumber</code></a> and <a href="https://docs.rs/gherkin"><code>gherkin</code></a> crates support content types and backticks as the delimiter, many tools like text editors donâ€™t (yet).</p>
</blockquote>
<p>In a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function, thereâ€™s no need to find this text and match it with a pattern. Instead, it may be accessed via <a href="https://docs.rs/gherkin/*/gherkin/struct.Step.html"><code>Step</code></a> argument:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{gherkin::Step, given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
async fn hungry_cat(world: &amp;mut AnimalWorld, step: &amp;Step, state: String) {
    // Feed only Leo and Felix.
    if !step
        .docstring
        .as_ref()
        .map_or(false, |text| text.contains(&quot;Felix&quot;) || text.contains(&quot;Leo&quot;))
    {
        panic!(&quot;Only Felix and Leo can be fed&quot;);
    }

    match state.as_str() {
        &quot;hungry&quot; =&gt; world.cat.hungry = true,
        &quot;satiated&quot; =&gt; world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}
<span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::cucumber()
</span><span class="boring">        .run_and_exit(&quot;/tests/features/book/writing/doc_strings.feature&quot;)
</span><span class="boring">        .await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_doc_strings.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rule-keyword"><a class="header" href="#rule-keyword"><code>Rule</code> keyword</a></h1>
<p>The purpose of the <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code> keyword</a> is to represent a business rule that should be implemented. It provides additional information for a <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>. A <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code></a> is used to group together several <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s belonging to the business rule. A <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code></a> should contain one or more <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s illustrating the particular rule.</p>
<p>No additional work is required on the implementation side to support <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code>s</a>.</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Rule: Hungry cat becomes satiated
      
    Scenario: If we feed a hungry cat it will no longer be hungry
      Given a hungry cat
      When I feed the cat
      Then the cat is not hungry
    
  Rule: Satiated cat remains the same
      
    Scenario: If we feed a satiated cat it will not become hungry
      Given a satiated cat
      When I feed the cat
      Then the cat is not hungry
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    sleep(Duration::from_secs(2)).await;

    match state.as_str() {
        &quot;hungry&quot; =&gt; world.cat.hungry = true,
        &quot;satiated&quot; =&gt; world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}

#[when(&quot;I feed the cat&quot;)]
async fn feed_cat(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    world.cat.feed();
}

#[then(&quot;the cat is not hungry&quot;)]
async fn cat_is_fed(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    assert!(!world.cat.hungry);
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/rule.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_rule.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background-keyword"><a class="header" href="#background-keyword"><code>Background</code> keyword</a></h1>
<p>Occasionally, we may find ourselves repeating the same <a href="https://cucumber.io/docs/gherkin/reference#given"><code>Given</code></a> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s in all the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s of a <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>.</p>
<p>Since it's repeated in each <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>, this is an indication that those <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s are not quite <em>essential</em> to describe the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s, but rather are <em>incidental details</em>. So, we can move such <a href="https://cucumber.io/docs/gherkin/reference#given"><code>Given</code></a> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s to background, by grouping them under a <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> section.</p>
<p><a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> allows you to add some context to the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s following it. It can contain one or more <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s, which are run before each <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> (but after any <a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hooks</a>).</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Background: 
    Given a hungry cat
    
  Rule: Hungry cat becomes satiated
      
    Scenario: If we feed a hungry cat it will no longer be hungry
      When I feed the cat
      Then the cat is not hungry
    
  Rule: Satiated cat remains the same
      
    Background:
      When I feed the cat

    Scenario: If we feed a satiated cat it will not become hungry
      When I feed the cat
      Then the cat is not hungry
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    sleep(Duration::from_secs(2)).await;

    match state.as_str() {
        &quot;hungry&quot; =&gt; world.cat.hungry = true,
        &quot;satiated&quot; =&gt; world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}

#[when(&quot;I feed the cat&quot;)]
async fn feed_cat(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    world.cat.feed();
}

#[then(&quot;the cat is not hungry&quot;)]
async fn cat_is_fed(world: &amp;mut AnimalWorld) {
    sleep(Duration::from_secs(2)).await;

    assert!(!world.cat.hungry);
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/background.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_background.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s indicated by <code>&gt;</code> mark in the output.</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong>: In case <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> is declared outside any <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code></a>, it will be run on any <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>. Otherwise, if <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> is declared inside a <a href="https://cucumber.io/docs/gherkin/reference#rule"><code>Rule</code></a>, it will be run only for <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s belonging to it, and only after top-level <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s (if any).</p>
</blockquote>
<h2 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h2>
<ul>
<li>Donâ€™t use <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> to set up complicated states, unless that state is actually something the client needs to know.</li>
<li>Keep your <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> section short.</li>
<li>Make your <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> section vivid, use colorful names, and try to tell a story.</li>
<li>Keep your <a href="https://cucumber.io/docs/gherkin/reference#example"><code>Scenario</code>s</a> short, and donâ€™t have too many.</li>
</ul>
<p>Clearly, example provided above doesn't need <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a> and was made for demonstration purposes only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scenario-outline-keyword"><a class="header" href="#scenario-outline-keyword"><code>Scenario Outline</code> keyword</a></h1>
<p>The <a href="https://cucumber.io/docs/gherkin/reference#scenario-outline"><code>Scenario Outline</code></a> keyword can be used to run the same <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> multiple times, with different combinations of values.</p>
<pre><code class="language-gherkin">Feature: Animal feature

  Scenario Outline: If we feed a hungry animal it will no longer be hungry
    Given a hungry &lt;animal&gt;
    When I feed the &lt;animal&gt; &lt;n&gt; times
    Then the &lt;animal&gt; is not hungry

  Examples: 
    | animal | n |
    | cat    | 2 |
    | dog    | 3 |
    | ðŸ¦€     | 4 |
</code></pre>
<p>At parsing stage <code>&lt;template&gt;</code>s are replaced by value from cells, so we may get that value in <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching functions (if we need though).</p>
<blockquote>
<p><strong>NOTE</strong>: <code>&lt;template&gt;</code>s are replaced even inside <a href="writing/doc_strings.html">doc strings</a> and <a href="writing/data_tables.html">data tables</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{collections::HashMap, convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span>#[derive(Debug, Default)]
struct Animal {
    pub hungry: bool,
}

impl Animal {
    fn feed(&amp;mut self) {
        self.hungry = false;
    }
}

#[derive(Debug, WorldInit)]
pub struct AnimalWorld {
    animals: HashMap&lt;String, Animal&gt;,
}

#[async_trait(?Send)]
impl World for AnimalWorld {
    type Error = Infallible;

    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
        Ok(Self {
            animals: HashMap::new(),
        })
    }
}

#[given(regex = r&quot;^a (hungry|satiated) (\S+)$&quot;)]
async fn hungry_animal(world: &amp;mut AnimalWorld, state: String, which: String) {
    sleep(Duration::from_secs(2)).await;

    world.animals.entry(which).or_insert(Animal::default()).hungry =
        match state.as_str() {
            &quot;hungry&quot; =&gt; true,
            &quot;satiated&quot; =&gt; false,
            _ =&gt; unreachable!(),
        };
}

#[when(expr = &quot;I feed the {word} {int} time(s)&quot;)]
async fn feed_animal(world: &amp;mut AnimalWorld, which: String, times: usize) {
    sleep(Duration::from_secs(2)).await;

    for _ in 0..times {
        world.animals.get_mut(&amp;which).map(Animal::feed);
    }
}

#[then(expr = &quot;the {word} is not hungry&quot;)]
async fn animal_is_fed(world: &amp;mut AnimalWorld, which: String) {
    sleep(Duration::from_secs(2)).await;

    assert!(!world.animals.get(&amp;which).map_or(true, |a| a.hungry));
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/scenario_outline.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://cucumber.io/docs/gherkin/reference#scenario-outline"><code>Scenario Outline</code></a> runs the whole <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> for each table row separately, unlike <a href="writing/data_tables.html">data tables</a>, which run the whole table inside a single <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>.</p>
</blockquote>
<p><img src="writing/../rec/writing_scenario_outline.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scenario-hooks"><a class="header" href="#scenario-hooks">Scenario hooks</a></h1>
<p><a href="https://cucumber.io/docs/cucumber/api#scenario-hooks">Scenario hooks</a> represent a code running for each <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> and not visible in <code>.feature</code> files.</p>
<h2 id="before-hook"><a class="header" href="#before-hook"><code>Before</code> hook</a></h2>
<p><a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hook</a> runs before the first step of each scenario, even before <a href="writing/background.html"><code>Background</code></a> ones.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::WorldInit;
</span><span class="boring">use futures::FutureExt as _;
</span><span class="boring">use tokio::time;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(World)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>World::cucumber()
    .before(|_feature, _rule, _scenario, _world| {
        time::sleep(Duration::from_millis(300)).boxed_local()
    })
    .run_and_exit(&quot;tests/features/book&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hook</a> is enabled globally for all the executed <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s. No exception is possible.</p>
</blockquote>
<blockquote>
<p><strong>WARNING</strong>: <strong>Think twice before using <a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hook</a>!</strong><br />
Whatever happens in a <a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hook</a> is invisible to people reading <code>.feature</code>s. You should consider using a <a href="writing/background.html"><code>Background</code></a> keyword as a more explicit alternative, especially if the setup should be readable by non-technical people. Only use a <a href="https://cucumber.io/docs/cucumber/api#before"><code>Before</code> hook</a> for low-level logic such as starting a browser or deleting data from a database.</p>
</blockquote>
<h2 id="after-hook"><a class="header" href="#after-hook"><code>After</code> hook</a></h2>
<p><a href="https://cucumber.io/docs/cucumber/api#after"><code>After</code> hook</a> runs after the last <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> of each <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>, even when that <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> fails or is skipped.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::WorldInit;
</span><span class="boring">use futures::FutureExt as _;
</span><span class="boring">use tokio::time;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(World)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>World::cucumber()
    .after(|_feature, _rule, _scenario, _world| {
        time::sleep(Duration::from_millis(300)).boxed_local()
    })
    .run_and_exit(&quot;tests/features/book&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://cucumber.io/docs/cucumber/api#after"><code>After</code> hook</a> is enabled globally for all the executed <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s. No exception is possible.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spoken-languages"><a class="header" href="#spoken-languages">Spoken languages</a></h1>
<p>The language chosen for <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a> should be the same language users and domain experts use when they talk about the domain. Translating between two languages should be avoided.</p>
<p>This is why <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a> has been translated to over <a href="https://cucumber.io/docs/gherkin/languages">70 languages</a>.</p>
<p>A <code># language:</code> header on the first line of a <code>.feature</code> file tells <a href="https://cucumber.io">Cucumber</a> which spoken language to use (for example, <code># language: fr</code> for French). If you omit this header, <a href="https://cucumber.io">Cucumber</a> will default to English (<code>en</code>).</p>
<pre><code class="language-gherkin"># language: no

Egenskap: Dyr egenskap

  Scenario: Hvis vi mater en sulten katt, vil den ikke lenger vÃ¦re sulten
    Gitt en sulten katt
    NÃ¥r jeg mater katten
    SÃ¥ katten er ikke sulten
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::convert::Infallible;
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cat {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Cat,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Cat { hungry: false },
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[given(regex = r&quot;^en (sulten|mett) katt$&quot;)]
async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
    match state.as_str() {
        &quot;sulten&quot; =&gt; world.cat.hungry = true,
        &quot;mett&quot; =&gt; world.cat.hungry = false,
        _ =&gt; unreachable!(),
    }
}

#[when(&quot;jeg mater katten&quot;)]
async fn feed_cat(world: &amp;mut AnimalWorld) {
    world.cat.feed();
}

#[then(&quot;katten er ikke sulten&quot;)]
async fn cat_is_fed(world: &amp;mut AnimalWorld) {
    assert!(!world.cat.hungry);
}
<span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::run(&quot;/tests/features/book/writing/languages.feature&quot;).await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="writing/../rec/writing_languages.gif" alt="record" /></p>
<blockquote>
<p><strong>TIP</strong>: In case most of your <code>.feature</code> files aren't written in English and you want to avoid endless <code># language:</code> comments, use <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.language"><code>Cucumber::language()</code></a> method to override the default language globally.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tags"><a class="header" href="#tags">Tags</a></h1>
<p><a href="https://cucumber.io/docs/cucumber/api#tags">Tags</a> represent meta information of <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s and <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s.</p>
<p>They can be used for different purposes, but in the majority of cases it's just:</p>
<ul>
<li>either running a subset of <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s filtering by <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>;</li>
<li>or making <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> run in isolation via <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>;</li>
<li>or allowing <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s to be skipped with <code>@allow.skipped</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>.</li>
</ul>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>A <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> may have as many <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s as it requires (they should be separated with spaces):</p>
<pre><code class="language-gherkin">Feature: Animal feature

  @hungry
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  @satiated @second
  Scenario: If we feed a satiated cat it will not become hungry
    Given a satiated cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p>To filter out running <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s we may use:</p>
<ul>
<li>either <code>--tags</code> <a href="writing/../cli.html">CLI</a> option providing <a href="https://cucumber.io/docs/cucumber/api#tag-expressions">tag expressions</a> (also consider <a href="https://github.com/cucumber/tag-expressions/tree/6f444830b23bd8e0c5a2617cd51b91bc2e05adde#escaping">escaping</a>);</li>
<li>or <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.filter_run"><code>filter_run()</code></a>-like method.</li>
</ul>
<p><img src="writing/../rec/writing_tags_filtering.gif" alt="record" /></p>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p><a href="https://cucumber.io/docs/cucumber/api#tags">Tags</a> may be placed above the following <a href="https://cucumber.io/docs/gherkin/reference">Gherkin</a> elements:</p>
<ul>
<li><a href="https://cucumber.io/docs/gherkin/reference#feature"><code>Feature</code></a></li>
<li><a href="https://cucumber.io/docs/gherkin/reference#example"><code>Scenario</code></a></li>
<li><a href="writing/scenario_outline.html"><code>Scenario Outline</code></a></li>
<li><a href="https://cucumber.io/docs/gherkin/reference#examples"><code>Examples</code></a></li>
</ul>
<p>It's <em>not</em> possible to place <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s above <a href="writing/background.html"><code>Background</code></a> or <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s (<code>Given</code>, <code>When</code>, <code>Then</code>, <code>And</code> and <code>But</code>).</p>
<p><a href="https://cucumber.io/docs/cucumber/api#tags">Tags</a> are inherited by child elements:</p>
<ul>
<li><a href="https://cucumber.io/docs/gherkin/reference#feature"><code>Feature</code></a> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s will be inherited by <a href="https://cucumber.io/docs/gherkin/reference#example"><code>Scenario</code></a>, <a href="writing/scenario_outline.html"><code>Scenario Outline</code></a>, or <a href="https://cucumber.io/docs/gherkin/reference#examples"><code>Examples</code></a>.</li>
<li><a href="writing/scenario_outline.html"><code>Scenario Outline</code></a> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s will be inherited by <a href="https://cucumber.io/docs/gherkin/reference#examples"><code>Examples</code></a>.</li>
</ul>
<pre><code class="language-gherkin">@feature
Feature: Animal feature

  @scenario
  Scenario Outline: If we feed a hungry animal it will no longer be hungry
    Given a hungry &lt;animal&gt;
    When I feed the &lt;animal&gt; &lt;n&gt; times
    Then the &lt;animal&gt; is not hungry

  @home
  Examples: 
    | animal | n |
    | cat    | 2 |
    | dog    | 3 |

  @dire
  Examples: 
    | animal | n |
    | lion   | 1 |
    | wolf   | 1 |
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: In <a href="writing/scenario_outline.html"><code>Scenario Outline</code></a> it's possible to use <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s on different <a href="https://cucumber.io/docs/gherkin/reference#examples"><code>Examples</code></a>.</p>
</blockquote>
<p><img src="writing/../rec/writing_tags_inheritance.gif" alt="record" /></p>
<h2 id="isolated-execution"><a class="header" href="#isolated-execution">Isolated execution</a></h2>
<p><a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate provides out-of-the-box support for <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>. Any <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> marked with <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> will be executed in isolation, ensuring that there are no other <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s running concurrently at the moment.</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  @serial
  Scenario: If we feed a satiated cat it will not become hungry
    Given a satiated cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> may also be used for filtering as a regular one.</p>
</blockquote>
<p><img src="writing/../rec/writing_tags_serial.gif" alt="record" /></p>
<blockquote>
<p><strong>TIP</strong>: To run the whole test suite serially, consider using <code>--concurrency=1</code> <a href="writing/../cli.html">CLI</a> option, rather than marking evey single <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a> with a <code>@serial</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>.</p>
</blockquote>
<h2 id="failing-on-skipped-steps"><a class="header" href="#failing-on-skipped-steps">Failing on skipped <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s</a></h2>
<p>As a test suit grows, it may become harder to notice how minimal changes to <a href="writing/capturing.html">regular expressions</a> can lead to mismatched <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s.</p>
<p>Using <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.fail_on_skipped"><code>Cucumber::fail_on_skipped()</code></a> method fails the whole test suite if some <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s miss the implementation, so ensures that the whole test suite is covered.</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  Scenario: If we feed a satiated cat it will not become hungry
    Given a wild cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .fail_on_skipped()
        .run_and_exit(&quot;/tests/features/book/writing/tags_skip_failed.feature&quot;)
        .await;
}
</code></pre></pre>
<blockquote>
<p><strong>TIP</strong>: Using <code>@allow.skipped</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> allows <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s being skipped even in <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.fail_on_skipped"><code>Cucumber::fail_on_skipped()</code></a> mode. Use the one to intentionally skip the implementation.</p>
</blockquote>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
    When I feed the cat
    Then the cat is not hungry

  @allow.skipped
  Scenario: If we feed a satiated cat it will not become hungry
    Given a wild cat
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<p><img src="writing/../rec/writing_tags_skip.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: <code>@allow.skipped</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a> may also be used for filtering as a regular one.</p>
</blockquote>
<p><img src="writing/../rec/writing_tags_skip_filter.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-organization"><a class="header" href="#modules-organization">Modules organization</a></h1>
<p>When the project is started it's okay to have all the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s defined in a single <code>.feature</code> file. However, as the project grows, it will be more efficient to split all the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s into meaningful groups in different <code>.feature</code> files. This will make the project tests more logically organized and easier to maintain.</p>
<h2 id="grouping"><a class="header" href="#grouping">Grouping</a></h2>
<p>Technically, it doesn't matter how <code>.feature</code> files are named, or which <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s are put in there. However, as the project grows, big <code>.feature</code> files becomes messy and hard to maintain. Instead, we recommend creating a separate <code>.rs</code> file for each domain concept (in a way that is meaningful to <em>your</em> project).</p>
<p>Following this pattern allows us also to avoid the <a href="https://cucumberio/docs/guides/anti-patterns/#feature-coupled-step-definitions">feature-coupled step definitions</a> anti-pattern.</p>
<h2 id="avoiding-duplication"><a class="header" href="#avoiding-duplication">Avoiding duplication</a></h2>
<p>It's better to avoid writing similar <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching functions, as they can lead to clutter. While documenting <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s helps, making use of <a href="writing/capturing.html">regular and Cucumber expressions</a> can do wonders.</p>
<h2 id="managing-growth"><a class="header" href="#managing-growth">Managing growth</a></h2>
<p>As the test suit grows, it may become harder to notice how minimal changes to regular expressions can lead to mismatched <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s. </p>
<blockquote>
<p><strong>TIP</strong>: We recommend using <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.fail_on_skipped"><code>Cucumber::fail_on_skipped()</code></a> method in combination with <code>@allow.skipped</code> <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>. The latter allows marking the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s which <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s are explicitly allowed to be skipped.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-command-line-interface"><a class="header" href="#cli-command-line-interface">CLI (command-line interface)</a></h1>
<p><a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate provides several options that can be passed to the command-line.</p>
<p>Use <code>--help</code> flag to print out all the available options:</p>
<pre><code class="language-bash">cargo test --test &lt;test-name&gt; -- --help
</code></pre>
<p>Default output is:</p>
<pre><code>cucumber
Run the tests, pet a dog!

USAGE:
    cucumber [OPTIONS]

OPTIONS:
    -c, --concurrency &lt;int&gt;
            Number of scenarios to run concurrently. If not specified, uses the value configured in
            tests runner, or 64 by default

        --color &lt;auto|always|never&gt;
            Coloring policy for a console output
            
            [default: auto]
            
        --fail-fast
            Run tests until the first failure

    -h, --help
            Print help information

    -i, --input &lt;glob&gt;
            Glob pattern to look for feature files with. By default, looks for `*.feature`s in the
            path configured tests runner

    -n, --name &lt;regex&gt;
            Regex to filter scenarios by their name
            
            [aliases: scenario-name]

    -t, --tags &lt;tagexpr&gt;
            Tag expression to filter scenarios by.
            
            Note: Tags from Feature, Rule and Scenario are merged together on filtering, so be
            careful about conflicting tags on different levels.

    -v
            Verbosity of an output.
            
            `-v` is default verbosity, `-vv` additionally outputs world on failed steps, `-vvv`
            additionally outputs step's doc string (if present).
</code></pre>
<p><img src="rec/cli.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: CLI options override any configurations set in the code.</p>
</blockquote>
<h2 id="customizing"><a class="header" href="#customizing">Customizing</a></h2>
<p>By default, the whole CLI is composed of <a href="https://docs.rs/cucumber/*/cucumber/trait.Parser.html#associatedtype.Cli"><code>Parser::Cli</code></a>, <a href="https://docs.rs/cucumber/*/cucumber/trait.Runner.html#associatedtype.Cli"><code>Runner::Cli</code></a> and <a href="https://docs.rs/cucumber/*/cucumber/trait.Writer.html#associatedtype.Cli"><code>Writer::Cli</code></a>, provided by the used components. Once a custom <a href="architecture/parser.html"><code>Parser</code></a>, <a href="architecture/runner.html"><code>Runner</code></a> or <a href="architecture/writer.html"><code>Writer</code></a> is used, its CLI is automatically emerged into the final CLI.</p>
<p>CLI may be extended even more with arbitrary options, if required. In such case we should combine the final CLI by ourselves and apply it via <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.with_cli"><code>Cucumber::with_cli()</code></a> method.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{cli, given, then, when, World, WorldInit};
</span><span class="boring">use futures::FutureExt as _;
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(cli::Args)] // re-export of `clap::Args`
struct CustomOpts {
    /// Additional time to wait in before hook.
    #[clap(
        long,
        parse(try_from_str = humantime::parse_duration)
    )]
    pre_pause: Option&lt;Duration&gt;,
}

#[tokio::main]
async fn main() {
    let opts = cli::Opts::&lt;_, _, _, CustomOpts&gt;::parsed();
    let pre_pause = opts.custom.pre_pause.unwrap_or_default();

    AnimalWorld::cucumber()
        .before(move |_, _, _, _| sleep(pre_pause).boxed_local())
        .with_cli(opts)
        .run_and_exit(&quot;/tests/features/book/cli.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="rec/cli_custom.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: For extending CLI options of exising <a href="architecture/parser.html"><code>Parser</code></a>, <a href="architecture/runner.html"><code>Runner</code></a> or <a href="architecture/writer.html"><code>Writer</code></a> when wrapping it, consider using <a href="https://docs.rs/cucumber/*/cucumber/cli/struct.Compose.html"><code>cli::Compose</code></a>.</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong>: If a custom <a href="architecture/parser.html"><code>Parser</code></a>, <a href="architecture/runner.html"><code>Runner</code></a> or <a href="architecture/writer.html"><code>Writer</code></a> implementation doesn't expose any CLI options, then <a href="https://docs.rs/cucumber/*/cucumber/cli/struct.Empty.html"><code>cli::Empty</code></a> should be used.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output"><a class="header" href="#output">Output</a></h1>
<p>This chapter describes possible way and tweaks of outputting test suite results.</p>
<ol>
<li><a href="output/terminal.html">Terminal</a></li>
<li><a href="output/junit.html">JUnit XML report</a></li>
<li><a href="output/json.html">Cucumber JSON format</a></li>
<li><a href="output/multiple.html">Multiple outputs</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-output"><a class="header" href="#terminal-output">Terminal output</a></h1>
<p>By <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default</a>, <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate outputs tests result to <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">STDOUT</a>. It provides some <a href="https://docs.rs/cucumber/*/cucumber/writer/basic/struct.Cli.html">CLI options</a> for configuring the output.</p>
<h2 id="verbosity"><a class="header" href="#verbosity">Verbosity</a></h2>
<p>By <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default</a>, <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate tries to keep the output quite minimal, but its verbosity may be increased with <code>-v</code> CLI option.</p>
<p>Just specifying <code>-v</code> makes no difference, as it refers to the default verbosity level (no additional info).</p>
<h3 id="output-world-on-failures--vv"><a class="header" href="#output-world-on-failures--vv">Output <code>World</code> on failures (<code>-vv</code>)</a></h3>
<p>Increasing verbosity level with <code>-vv</code> CLI option, makes the state of the <code>World</code> being printed at the moment of failure.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[when(&quot;I feed the cat&quot;)]
async fn feed_cat(_: &amp;mut AnimalWorld) {}
<span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::cucumber()
</span><span class="boring">        .run_and_exit(&quot;/tests/features/book/output/terminal_verbose.feature&quot;)
</span><span class="boring">        .await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="output/../rec/output_terminal_verbose_1.gif" alt="record" /></p>
<p>This is intended to help debugging failed tests. </p>
<h3 id="output-doc-strings--vvv"><a class="header" href="#output-doc-strings--vvv">Output <a href="https://cucumber.io/docs/gherkin/reference#doc-strings">doc strings</a> (<code>-vvv</code>)</a></h3>
<p>By <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default</a>, outputting <a href="https://cucumber.io/docs/gherkin/reference#doc-strings">doc strings</a> of <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s is omitted. To include them into the output use <code>-vvv</code> CLI option:</p>
<pre><code class="language-gherkin">Feature: Animal feature
    
  Scenario: If we feed a hungry cat it will no longer be hungry
    Given a hungry cat
      &quot;&quot;&quot;
      A hungry cat called Felix is rescued from a Whiskas tin in a calamitous 
      mash-up of cat food brands.
      &quot;&quot;&quot;
    When I feed the cat
    Then the cat is not hungry
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .run_and_exit(&quot;/tests/features/book/output/terminal_verbose.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="output/../rec/output_terminal_verbose_2.gif" alt="record" /></p>
<h2 id="coloring"><a class="header" href="#coloring">Coloring</a></h2>
<p>Coloring may be disabled by specifying <code>--color</code> CLI option:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .run_and_exit(&quot;/tests/features/book/output/terminal.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="output/../rec/output_terminal_color.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: By <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default</a>, <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate automatically disables coloring for non-interactive terminals, so there is no need to specify <code>--color</code> CLI option explicitly on <a href="https://en.wikipedia.org/wiki/Continuous_integration">CI</a>.</p>
</blockquote>
<h2 id="manual-printing"><a class="header" href="#manual-printing">Manual printing</a></h2>
<p>Though <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate doesn't capture any manual printing produced in a <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> matching function (such as <a href="https://doc.rust-lang.org/stable/std/macro.dbg.html"><code>dbg!</code></a> or <a href="https://doc.rust-lang.org/stable/std/macro.println.html"><code>println!</code></a> macros), it may be <a href="https://github.com/cucumber-rs/cucumber/issues/177">quite misleading</a> to produce and use it for debugging purposes. The reason is simply because <a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate executes <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s concurrently and <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Normalize.html">normalizes</a> their results before outputting, while any manual print is produced instantly at the moment of its <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> execution.</p>
<blockquote>
<p><strong>WARNING:</strong> Moreover, manual printing will very likely interfere with <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default</a> interactive pretty-printing.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[when(&quot;I feed the cat&quot;)]
async fn feed_cat(world: &amp;mut AnimalWorld) {
<span class="boring">    sleep(Duration::from_secs(2)).await;
</span>    dbg!(&quot;here!&quot;);
    world.cat.feed();
}
<span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">    AnimalWorld::cucumber()
</span><span class="boring">        .run_and_exit(&quot;/tests/features/book/output/terminal.feature&quot;)
</span><span class="boring">        .await;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="output/../rec/output_terminal_custom_bad.gif" alt="record" /></p>
<p>To achieve natural output for debugging, the following preparations are required:</p>
<ol>
<li>Setting <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.max_concurrent_scenarios"><code>.max_concurrent_scenarios()</code></a> to <code>1</code> for executing all the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s sequentially.</li>
<li>Creating <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html#method.raw"><code>writer::Basic::raw</code></a> with <a href="https://docs.rs/cucumber/*/cucumber/writer/enum.Coloring.html#variant.Never"><code>Coloring::Never</code></a> to avoid interactive pretty-printed output.</li>
<li>Wrapping it into <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.AssertNormalized.html"><code>writer::AssertNormalized</code></a> to assure <a href="https://docs.rs/cucumber"><code>cucumber</code></a> about the output being <a href="https://docs.rs/cucumber/*/cucumber/writer/trait.Normalized.html">normalized</a> already (due to sequential execution).</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, io, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, writer, World, WorldInit, WriterExt as _};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">    dbg!(&quot;here!&quot;);    
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .max_concurrent_scenarios(1)
        .with_writer(
            writer::Basic::raw(io::stdout(), writer::Coloring::Never, 0)
                .summarized()
                .assert_normalized(),
        )
        .run_and_exit(&quot;/tests/features/book/output/terminal.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="output/../rec/output_terminal_custom.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: The custom print is still output before its <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>, because is printed during the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a> execution. </p>
</blockquote>
<h2 id="repeating-failed-andor-skipped-steps"><a class="header" href="#repeating-failed-andor-skipped-steps">Repeating failed and/or skipped <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s</a></h2>
<p>As a number of <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s grows, it may become quite difficult to find failed/skipped ones in a large output. This issue may be mitigated by duplicating failed and/or skipped <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s at the and of output via <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.repeat_failed"><code>Cucumber::repeat_failed()</code></a> and <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html#method.repeat_skipped"><code>Cucumber::repeat_skipped()</code></a> methods respectively.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .repeat_failed()
        .run_and_exit(&quot;/tests/features/book/output/terminal_repeat_failed.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="output/../rec/output_terminal_repeat_failed.gif" alt="record" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{given, then, when, World, WorldInit};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber()
        .repeat_skipped()
        .run_and_exit(&quot;/tests/features/book/output/terminal_repeat_skipped.feature&quot;)
        .await;
}
</code></pre></pre>
<p><img src="output/../rec/output_terminal_repeat_skipped.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="junit-xml-report"><a class="header" href="#junit-xml-report">JUnit XML report</a></h1>
<p><a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate provides an ability to output tests result as a <a href="https://llg.cubic.org/docs/junit">JUnit XML report</a>.</p>
<p>This requires <code>output-junit</code> feature to be enabled in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">cucumber = { version = &quot;0.11&quot;, features = [&quot;output-junit&quot;] }
</code></pre>
<p>And configuring output to <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.JUnit.html"><code>writer::JUnit</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, fs, io};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::WorldInit;
</span>use cucumber::writer;

<span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(World)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; io::Result&lt;()&gt; {
</span>let file = fs::File::create(dbg!(format!(&quot;{}/target/junit.xml&quot;, env!(&quot;CARGO_MANIFEST_DIR&quot;))))?;
World::cucumber()
    .with_writer(writer::JUnit::new(file, 0))
    .run(&quot;tests/features/book&quot;)
    .await;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cucumber-json-format"><a class="header" href="#cucumber-json-format">Cucumber JSON format</a></h1>
<p><a href="https://docs.rs/cucumber"><code>cucumber</code></a> crate provides an ability to output tests result in a <a href="https://github.com/cucumber/cucumber-json-schema">Cucumber JSON format</a>.</p>
<p>This requires <code>output-json</code> feature to be enabled in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">cucumber = { version = &quot;0.11&quot;, features = [&quot;output-json&quot;] }
</code></pre>
<p>And configuring output to <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Json.html"><code>writer::Json</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, fs, io};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::WorldInit;
</span>use cucumber::writer;

<span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(World)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; io::Result&lt;()&gt; {
</span>let file = fs::File::create(dbg!(format!(&quot;{}/target/report.json&quot;, env!(&quot;CARGO_MANIFEST_DIR&quot;))))?;
World::cucumber()
    .with_writer(writer::Json::new(file))
    .run(&quot;tests/features/book&quot;)
    .await;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-outputs"><a class="header" href="#multiple-outputs">Multiple outputs</a></h1>
<p>Reporting tests result to multiple outputs simultaneously may be achieved by using <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Tee.html"><code>writer::Tee</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, fs, io};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::WorldInit;
</span>use cucumber::{writer, WriterExt as _};

<span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">struct World;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl cucumber::World for World {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        Ok(World)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; io::Result&lt;()&gt; {
</span>let file = fs::File::create(dbg!(format!(&quot;{}/target/report.json&quot;, env!(&quot;CARGO_MANIFEST_DIR&quot;))))?;
World::cucumber()
    .with_writer(
        // NOTE: `Writer`s pipeline is constructed in a reversed order.
        writer::Basic::stdout() // And output to STDOUT.
            .summarized()       // Simultaneously, add execution summary.
            .tee::&lt;World, _&gt;(writer::Json::for_tee(file)) // Then, output to JSON file.
            .normalized()       // First, normalize events order.
    )
    .run_and_exit(&quot;tests/features/book&quot;)
    .await;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>On high level, the whole <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html"><code>Cucumber</code></a> is composed of three components:</p>
<ul>
<li><a href="https://docs.rs/cucumber/*/cucumber/trait.Parser.html"><code>Parser</code></a>, representing a source of <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s (<a href="https://docs.rs/cucumber/*/cucumber/parser/struct.Basic.html">default one</a> parses <code>.feature</code> files).</li>
<li><a href="https://docs.rs/cucumber/*/cucumber/trait.Runner.html"><code>Runner</code></a>, executing <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s of <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s received from a <a href="https://docs.rs/cucumber/*/cucumber/trait.Parser.html"><code>Parser</code></a>, and emitting <a href="https://docs.rs/cucumber/*/cucumber/event/index.html"><code>event</code></a>s (<a href="https://docs.rs/cucumber/*/cucumber/runner/struct.Basic.html">default one</a> executes concurrently).</li>
<li><a href="https://docs.rs/cucumber/*/cucumber/trait.Writer.html"><code>Writer</code></a>, outputting <a href="https://docs.rs/cucumber/*/cucumber/event/index.html"><code>event</code></a>s (<a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Basic.html">default one</a> outputs to STDOUT).</li>
</ul>
<p>Any of these components is replaceable. This makes <a href="https://docs.rs/cucumber/*/cucumber/struct.Cucumber.html"><code>Cucumber</code></a> fully extensible, without a need to rewrite the whole library if it doesn't meet some exotic requirements. One could always write its own component, satisfying the needs, and use it. Imagine the situation, where <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s are sourced from distributed queue (like <a href="https://kafka.apache.org">Kafka</a>), then executed by a cluster of external workers (like <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job">Kubernetes <code>Job</code>s</a>), and, finally, results are emitted to different reporting systems by network. All this possible by introducing custom components, capable of doing that, without a need to change the framework.</p>
<p>To feel a little bit of its taste, we will write some trivial implementations of each component in subchapters below. </p>
<ol>
<li><a href="architecture/parser.html">Custom <code>Parser</code></a></li>
<li><a href="architecture/runner.html">Custom <code>Runner</code></a></li>
<li><a href="architecture/writer.html">Custom <code>Writer</code></a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-parser"><a class="header" href="#custom-parser">Custom <code>Parser</code></a></h1>
<p>Let's start by implementing a custom <a href="https://docs.rs/cucumber/*/cucumber/trait.Parser.html"><code>Parser</code></a> which statically emits a single <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a> for execution.</p>
<p><a href="https://docs.rs/cucumber/*/cucumber/trait.Parser.html"><code>Parser</code></a> represents anything that emits a <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> of <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, path::PathBuf, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{cli, gherkin, given, parser, then, when, World, WorldInit};
</span><span class="boring">use futures::{future, stream};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomParser;

impl&lt;I&gt; cucumber::Parser&lt;I&gt; for CustomParser {
    type Cli = cli::Empty; // we provide no CLI options
    type Output = stream::Once&lt;future::Ready&lt;parser::Result&lt;gherkin::Feature&gt;&gt;&gt;;

    fn parse(self, _: I, _: Self::Cli) -&gt; Self::Output {
        let keyword = &quot;Feature&quot;;
        let name = &quot;Animal feature&quot;;
        stream::once(future::ok(gherkin::Feature {
            keyword: keyword.into(),
            name: name.into(),
            description: None,
            background: None,
            scenarios: vec![gherkin::Scenario {
                keyword: &quot;Scenario&quot;.into(),
                name: &quot;If we feed a hungry cat it won't be hungry&quot;.into(),
                steps: vec![
                    gherkin::Step {
                        keyword: &quot;Given&quot;.into(),
                        ty: gherkin::StepType::Given,
                        value: &quot;a hungry cat&quot;.into(),
                        docstring: None,
                        table: None,
                        span: gherkin::Span { start: 5, end: 18 },
                        position: gherkin::LineCol { line: 3, col: 5 },
                    },
                    gherkin::Step {
                        keyword: &quot;When&quot;.into(),
                        ty: gherkin::StepType::When,
                        value: &quot;I feed the cat&quot;.into(),
                        docstring: None,
                        table: None,
                        span: gherkin::Span { start: 5, end: 19 },
                        position: gherkin::LineCol { line: 4, col: 5 },
                    },
                    gherkin::Step {
                        keyword: &quot;Then&quot;.into(),
                        ty: gherkin::StepType::Then,
                        value: &quot;the cat is not hungry&quot;.into(),
                        docstring: None,
                        table: None,
                        span: gherkin::Span { start: 5, end: 26 },
                        position: gherkin::LineCol { line: 5, col: 5 },
                    },
                ],
                examples: vec![],
                tags: vec![],
                span: gherkin::Span { start: 3, end: 52 },
                position: gherkin::LineCol { line: 2, col: 3 },
            }],
            rules: vec![],
            tags: vec![],
            span: gherkin::Span { start: 1, end: 23 },
            position: gherkin::LineCol { line: 1, col: 1 },
            path: Some(PathBuf::from(file!())),
        }))
    }
}

#[tokio::main]
async fn main() {
    AnimalWorld::cucumber::&lt;&amp;str&gt;() // aiding type inference
        .with_parser(CustomParser)
        .run_and_exit(&quot;/tests/features/book&quot;) // path doesn't actually matter 
        .await;                               // here due to our implementation
}
</code></pre></pre>
<p><img src="architecture/../rec/architecture_parser.gif" alt="record" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-runner"><a class="header" href="#custom-runner">Custom <code>Runner</code></a></h1>
<p>Now, let's implement a custom <a href="https://docs.rs/cucumber/*/cucumber/trait.Runner.html"><code>Runner</code></a> which simply executes <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a>s in <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s sequentially, without considering <a href="https://cucumber.io/docs/cucumber/api#tags">tag</a>s, <a href="https://cucumber.io/docs/gherkin/reference#rule">rule</a>s, <a href="https://cucumber.io/docs/gherkin/reference#background"><code>Background</code></a>s or other extras, and specifically suitable for our <code>AnimalWorld</code> (for implementation simplicity).</p>
<p><a href="https://docs.rs/cucumber/*/cucumber/trait.Runner.html"><code>Runner</code></a> represents anything that transforms a <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> of <a href="https://cucumber.io/docs/gherkin/reference#feature">feature</a>s into a <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> of <a href="https://docs.rs/cucumber/*/cucumber/event/enum.Cucumber.html">cucumber events</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{
</span><span class="boring">    convert::Infallible,
</span><span class="boring">    panic::{self, AssertUnwindSafe},
</span><span class="boring">    path::PathBuf,
</span><span class="boring">    sync::Arc,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{
</span><span class="boring">    cli, event, gherkin, given, parser, step, then, when, Event, World,
</span><span class="boring">    WorldInit,
</span><span class="boring">};
</span><span class="boring">use futures::{
</span><span class="boring">    future::{self, FutureExt as _},
</span><span class="boring">    stream::{self, LocalBoxStream, Stream, StreamExt as _, TryStreamExt as _},
</span><span class="boring">};
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomParser;
</span><span class="boring">
</span><span class="boring">impl&lt;I&gt; cucumber::Parser&lt;I&gt; for CustomParser {
</span><span class="boring">    type Cli = cli::Empty;
</span><span class="boring">    type Output = stream::Once&lt;future::Ready&lt;parser::Result&lt;gherkin::Feature&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn parse(self, _: I, _: Self::Cli) -&gt; Self::Output {
</span><span class="boring">        let keyword = &quot;Feature&quot;;
</span><span class="boring">        let name = &quot;Animal feature&quot;;
</span><span class="boring">        stream::once(future::ok(gherkin::Feature {
</span><span class="boring">            keyword: keyword.into(),
</span><span class="boring">            name: name.into(),
</span><span class="boring">            description: None,
</span><span class="boring">            background: None,
</span><span class="boring">            scenarios: vec![gherkin::Scenario {
</span><span class="boring">                keyword: &quot;Scenario&quot;.into(),
</span><span class="boring">                name: &quot;If we feed a hungry cat it won't be hungry&quot;.into(),
</span><span class="boring">                steps: vec![
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Given&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Given,
</span><span class="boring">                        value: &quot;a hungry cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 18 },
</span><span class="boring">                        position: gherkin::LineCol { line: 3, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;When&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::When,
</span><span class="boring">                        value: &quot;I feed the cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 19 },
</span><span class="boring">                        position: gherkin::LineCol { line: 4, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Then&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Then,
</span><span class="boring">                        value: &quot;the cat is not hungry&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 26 },
</span><span class="boring">                        position: gherkin::LineCol { line: 5, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                ],
</span><span class="boring">                examples: vec![],
</span><span class="boring">                tags: vec![],
</span><span class="boring">                span: gherkin::Span { start: 3, end: 52 },
</span><span class="boring">                position: gherkin::LineCol { line: 2, col: 3 },
</span><span class="boring">            }],
</span><span class="boring">            rules: vec![],
</span><span class="boring">            tags: vec![],
</span><span class="boring">            span: gherkin::Span { start: 1, end: 23 },
</span><span class="boring">            position: gherkin::LineCol { line: 1, col: 1 },
</span><span class="boring">            path: Some(PathBuf::from(file!())),
</span><span class="boring">        }))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomRunner;

impl CustomRunner {
    fn steps_fns() -&gt; &amp;'static step::Collection&lt;AnimalWorld&gt; {
        // Wire the static collection of step matching functions.
        static STEPS: Lazy&lt;step::Collection&lt;AnimalWorld&gt;&gt; =
            Lazy::new(AnimalWorld::collection);
        &amp;STEPS
    }

    async fn execute_step(
        mut world: AnimalWorld,
        step: gherkin::Step,
    ) -&gt; (AnimalWorld, event::Step&lt;AnimalWorld&gt;) {
        let ev = if let Some((step_fn, captures, ctx)) =
            Self::steps_fns().find(&amp;step).expect(&quot;Ambiguous match&quot;)
        {
            // Panic represents a failed assertion in a step matching
            // function.
            match AssertUnwindSafe(step_fn(&amp;mut world, ctx))
                .catch_unwind()
                .await
            {
                Ok(()) =&gt; event::Step::Passed(captures),
                Err(e) =&gt; event::Step::Failed(
                    Some(captures),
                    Some(Arc::new(world.clone())),
                    event::StepError::Panic(e.into()),
                ),
            }
        } else {
            event::Step::Skipped
        };
        (world, ev)
    }

    async fn execute_scenario(
        scenario: gherkin::Scenario,
    ) -&gt; impl Stream&lt;Item = event::Feature&lt;AnimalWorld&gt;&gt; {
        // Those panic hook shenanigans are done to avoid console messages like
        // &quot;thread 'main' panicked at ...&quot;
        //
        // 1. We obtain the current panic hook and replace it with an empty one.
        // 2. We run tests, which can panic. In that case we pass all panic info
        //    down the line to the `Writer`, which will print it at right time.
        // 3. We restore original panic hook, because suppressing all panics
        //    doesn't sound like a very good idea.
        let hook = panic::take_hook();
        panic::set_hook(Box::new(|_| {}));

        let mut world = AnimalWorld::new().await.unwrap();
        let mut steps = Vec::with_capacity(scenario.steps.len());

        for step in scenario.steps.clone() {
            let (w, ev) = Self::execute_step(world, step.clone()).await;
            world = w;
            let should_stop = matches!(ev, event::Step::Failed(..));
            steps.push((step, ev));
            if should_stop {
                break;
            }
        }

        panic::set_hook(hook);

        let scenario = Arc::new(scenario);
        stream::once(future::ready(event::Scenario::Started))
            .chain(stream::iter(steps.into_iter().flat_map(|(step, ev)| {
                let step = Arc::new(step);
                [
                    event::Scenario::Step(step.clone(), event::Step::Started),
                    event::Scenario::Step(step, ev),
                ]
            })))
            .chain(stream::once(future::ready(event::Scenario::Finished)))
            .map(move |ev| event::Feature::Scenario(scenario.clone(), ev))
    }

    fn execute_feature(
        feature: gherkin::Feature,
    ) -&gt; impl Stream&lt;Item = event::Cucumber&lt;AnimalWorld&gt;&gt; {
        let feature = Arc::new(feature);
        stream::once(future::ready(event::Feature::Started))
            .chain(
                stream::iter(feature.scenarios.clone())
                    .then(Self::execute_scenario)
                    .flatten(),
            )
            .chain(stream::once(future::ready(event::Feature::Finished)))
            .map(move |ev| event::Cucumber::Feature(feature.clone(), ev))
    }
}

impl cucumber::Runner&lt;AnimalWorld&gt; for CustomRunner {
    type Cli = cli::Empty; // we provide no CLI options
    type EventStream = LocalBoxStream&lt;
        'static,
        parser::Result&lt;Event&lt;event::Cucumber&lt;AnimalWorld&gt;&gt;&gt;,
    &gt;;

    fn run&lt;S&gt;(self, features: S, _: Self::Cli) -&gt; Self::EventStream
    where
        S: Stream&lt;Item = parser::Result&lt;gherkin::Feature&gt;&gt; + 'static,
    {
        stream::once(future::ok(event::Cucumber::Started))
            .chain(
                features
                    .map_ok(|f| Self::execute_feature(f).map(Ok))
                    .try_flatten(),
            )
            .chain(stream::once(future::ok(event::Cucumber::Finished)))
            .map_ok(Event::new)
            .boxed_local()
    }
}

#[tokio::main]
async fn main() {
    AnimalWorld::cucumber::&lt;&amp;str&gt;() // aiding type inference for `CustomParser`
        .with_parser(CustomParser)
        .with_runner(CustomRunner)
        .run_and_exit(&quot;/tests/features/book&quot;)
        .await;
}
</code></pre></pre>
<p><img src="architecture/../rec/architecture_runner.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: Output is printed only after all the <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s were executed, because we have implemented the <code>CustomRunner</code> in the way to emit <a href="https://docs.rs/cucumber/*/cucumber/event/enum.Cucumber.html"><code>event::Cucumber</code></a>s only after executing all the <a href="https://cucumber.io/docs/gherkin/reference#example">scenario</a> <a href="https://cucumber.io/docs/gherkin/reference#steps">step</a>s (see <code>execute_scenario()</code> function).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-writer"><a class="header" href="#custom-writer">Custom <code>Writer</code></a></h1>
<p>Finally, let's implement a custom <a href="https://docs.rs/cucumber/*/cucumber/writer/index.html"><code>Writer</code></a> which simply outputs <a href="https://docs.rs/cucumber/*/cucumber/event/enum.Cucumber.html">cucumber events</a> to <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">STDOUT</a> in the order of receiving.</p>
<p><a href="https://docs.rs/cucumber/*/cucumber/writer/index.html"><code>Writer</code></a> represents anything that consumes a <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> of <a href="https://docs.rs/cucumber/*/cucumber/event/enum.Cucumber.html">cucumber events</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{
</span><span class="boring">    convert::Infallible,
</span><span class="boring">    panic::{self, AssertUnwindSafe},
</span><span class="boring">    path::PathBuf,
</span><span class="boring">    sync::Arc,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{
</span><span class="boring">    cli, event, gherkin, given, parser, step, then, when, Event, World,
</span><span class="boring">    WorldInit, WriterExt as _,
</span><span class="boring">};
</span><span class="boring">use futures::{
</span><span class="boring">    future::{self, FutureExt as _},
</span><span class="boring">    stream::{self, LocalBoxStream, Stream, StreamExt as _, TryStreamExt as _},
</span><span class="boring">};
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomParser;
</span><span class="boring">
</span><span class="boring">impl&lt;I&gt; cucumber::Parser&lt;I&gt; for CustomParser {
</span><span class="boring">    type Cli = cli::Empty;
</span><span class="boring">    type Output = stream::Once&lt;future::Ready&lt;parser::Result&lt;gherkin::Feature&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn parse(self, _: I, _: Self::Cli) -&gt; Self::Output {
</span><span class="boring">        let keyword = &quot;Feature&quot;;
</span><span class="boring">        let name = &quot;Animal feature&quot;;
</span><span class="boring">        stream::once(future::ok(gherkin::Feature {
</span><span class="boring">            keyword: keyword.into(),
</span><span class="boring">            name: name.into(),
</span><span class="boring">            description: None,
</span><span class="boring">            background: None,
</span><span class="boring">            scenarios: vec![gherkin::Scenario {
</span><span class="boring">                keyword: &quot;Scenario&quot;.into(),
</span><span class="boring">                name: &quot;If we feed a hungry cat it won't be hungry&quot;.into(),
</span><span class="boring">                steps: vec![
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Given&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Given,
</span><span class="boring">                        value: &quot;a hungry cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 18 },
</span><span class="boring">                        position: gherkin::LineCol { line: 3, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;When&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::When,
</span><span class="boring">                        value: &quot;I feed the cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 19 },
</span><span class="boring">                        position: gherkin::LineCol { line: 4, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Then&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Then,
</span><span class="boring">                        value: &quot;the cat is not hungry&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 26 },
</span><span class="boring">                        position: gherkin::LineCol { line: 5, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                ],
</span><span class="boring">                examples: vec![],
</span><span class="boring">                tags: vec![],
</span><span class="boring">                span: gherkin::Span { start: 3, end: 52 },
</span><span class="boring">                position: gherkin::LineCol { line: 2, col: 3 },
</span><span class="boring">            }],
</span><span class="boring">            rules: vec![],
</span><span class="boring">            tags: vec![],
</span><span class="boring">            span: gherkin::Span { start: 1, end: 23 },
</span><span class="boring">            position: gherkin::LineCol { line: 1, col: 1 },
</span><span class="boring">            path: Some(PathBuf::from(file!())),
</span><span class="boring">        }))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomRunner;
</span><span class="boring">
</span><span class="boring">impl CustomRunner {
</span><span class="boring">    fn steps_fns() -&gt; &amp;'static step::Collection&lt;AnimalWorld&gt; {
</span><span class="boring">        static STEPS: Lazy&lt;step::Collection&lt;AnimalWorld&gt;&gt; =
</span><span class="boring">            Lazy::new(AnimalWorld::collection);
</span><span class="boring">        &amp;STEPS
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn execute_step(
</span><span class="boring">        mut world: AnimalWorld,
</span><span class="boring">        step: gherkin::Step,
</span><span class="boring">    ) -&gt; (AnimalWorld, event::Step&lt;AnimalWorld&gt;) {
</span><span class="boring">        let ev = if let Some((step_fn, captures, ctx)) =
</span><span class="boring">            Self::steps_fns().find(&amp;step).expect(&quot;Ambiguous match&quot;)
</span><span class="boring">        {
</span><span class="boring">            match AssertUnwindSafe(step_fn(&amp;mut world, ctx))
</span><span class="boring">                .catch_unwind()
</span><span class="boring">                .await
</span><span class="boring">            {
</span><span class="boring">                Ok(()) =&gt; event::Step::Passed(captures),
</span><span class="boring">                Err(e) =&gt; event::Step::Failed(
</span><span class="boring">                    Some(captures),
</span><span class="boring">                    Some(Arc::new(world.clone())),
</span><span class="boring">                    event::StepError::Panic(e.into()),
</span><span class="boring">                ),
</span><span class="boring">            }
</span><span class="boring">        } else {
</span><span class="boring">            event::Step::Skipped
</span><span class="boring">        };
</span><span class="boring">        (world, ev)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn execute_scenario(
</span><span class="boring">        scenario: gherkin::Scenario,
</span><span class="boring">    ) -&gt; impl Stream&lt;Item = event::Feature&lt;AnimalWorld&gt;&gt; {
</span><span class="boring">        let hook = panic::take_hook();
</span><span class="boring">        panic::set_hook(Box::new(|_| {}));
</span><span class="boring">
</span><span class="boring">        let mut world = AnimalWorld::new().await.unwrap();
</span><span class="boring">        let mut steps = Vec::with_capacity(scenario.steps.len());
</span><span class="boring">
</span><span class="boring">        for step in scenario.steps.clone() {
</span><span class="boring">            let (w, ev) = Self::execute_step(world, step.clone()).await;
</span><span class="boring">            world = w;
</span><span class="boring">            let should_stop = matches!(ev, event::Step::Failed(..));
</span><span class="boring">            steps.push((step, ev));
</span><span class="boring">            if should_stop {
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        panic::set_hook(hook);
</span><span class="boring">
</span><span class="boring">        let scenario = Arc::new(scenario);
</span><span class="boring">        stream::once(future::ready(event::Scenario::Started))
</span><span class="boring">            .chain(stream::iter(steps.into_iter().flat_map(|(step, ev)| {
</span><span class="boring">                let step = Arc::new(step);
</span><span class="boring">                [
</span><span class="boring">                    event::Scenario::Step(step.clone(), event::Step::Started),
</span><span class="boring">                    event::Scenario::Step(step, ev),
</span><span class="boring">                ]
</span><span class="boring">            })))
</span><span class="boring">            .chain(stream::once(future::ready(event::Scenario::Finished)))
</span><span class="boring">            .map(move |ev| event::Feature::Scenario(scenario.clone(), ev))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn execute_feature(
</span><span class="boring">        feature: gherkin::Feature,
</span><span class="boring">    ) -&gt; impl Stream&lt;Item = event::Cucumber&lt;AnimalWorld&gt;&gt; {
</span><span class="boring">        let feature = Arc::new(feature);
</span><span class="boring">        stream::once(future::ready(event::Feature::Started))
</span><span class="boring">            .chain(
</span><span class="boring">                stream::iter(feature.scenarios.clone())
</span><span class="boring">                    .then(Self::execute_scenario)
</span><span class="boring">                    .flatten(),
</span><span class="boring">            )
</span><span class="boring">            .chain(stream::once(future::ready(event::Feature::Finished)))
</span><span class="boring">            .map(move |ev| event::Cucumber::Feature(feature.clone(), ev))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl cucumber::Runner&lt;AnimalWorld&gt; for CustomRunner {
</span><span class="boring">    type Cli = cli::Empty;
</span><span class="boring">    type EventStream = LocalBoxStream&lt;
</span><span class="boring">        'static,
</span><span class="boring">        parser::Result&lt;Event&lt;event::Cucumber&lt;AnimalWorld&gt;&gt;&gt;,
</span><span class="boring">    &gt;;
</span><span class="boring">
</span><span class="boring">    fn run&lt;S&gt;(self, features: S, _: Self::Cli) -&gt; Self::EventStream
</span><span class="boring">    where
</span><span class="boring">        S: Stream&lt;Item = parser::Result&lt;gherkin::Feature&gt;&gt; + 'static,
</span><span class="boring">    {
</span><span class="boring">        stream::once(future::ok(event::Cucumber::Started))
</span><span class="boring">            .chain(
</span><span class="boring">                features
</span><span class="boring">                    .map_ok(|f| Self::execute_feature(f).map(Ok))
</span><span class="boring">                    .try_flatten(),
</span><span class="boring">            )
</span><span class="boring">            .chain(stream::once(future::ok(event::Cucumber::Finished)))
</span><span class="boring">            .map_ok(Event::new)
</span><span class="boring">            .boxed_local()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomWriter;

#[async_trait(?Send)]
impl&lt;W: 'static&gt; cucumber::Writer&lt;W&gt; for CustomWriter {
    type Cli = cli::Empty; // we provide no CLI options

    async fn handle_event(
        &amp;mut self,
        ev: parser::Result&lt;Event&lt;event::Cucumber&lt;W&gt;&gt;&gt;,
        _: &amp;Self::Cli,
    ) {
        match ev {
            Ok(Event { value, .. }) =&gt; match value {
                event::Cucumber::Feature(feature, ev) =&gt; match ev {
                    event::Feature::Started =&gt; {
                        println!(&quot;{}: {}&quot;, feature.keyword, feature.name)
                    }
                    event::Feature::Scenario(scenario, ev) =&gt; match ev {
                        event::Scenario::Started =&gt; {
                            println!(&quot;{}: {}&quot;, scenario.keyword, scenario.name)
                        }
                        event::Scenario::Step(step, ev) =&gt; match ev {
                            event::Step::Started =&gt; {
                                print!(&quot;{} {}...&quot;, step.keyword, step.value)
                            }
                            event::Step::Passed(_) =&gt; println!(&quot;ok&quot;),
                            event::Step::Skipped =&gt; println!(&quot;skip&quot;),
                            event::Step::Failed(_, _, err) =&gt; {
                                println!(&quot;failed: {err}&quot;)
                            }
                        },
                        _ =&gt; {}
                    },
                    _ =&gt; {}
                },
                _ =&gt; {}
            },
            Err(e) =&gt; println!(&quot;Error: {e}&quot;),
        }
    }
}

#[tokio::main]
async fn main() {
    AnimalWorld::cucumber::&lt;&amp;str&gt;() // aiding type inference for `CustomParser`
        .with_parser(CustomParser)
        .with_runner(CustomRunner)
        .with_writer(CustomWriter.assert_normalized()) // OK because of `CustomRunner`
        .run(&quot;/tests/features/book&quot;)
        .await;
}
</code></pre></pre>
<p><img src="architecture/../rec/architecture_writer_raw.gif" alt="record" /></p>
<blockquote>
<p><strong>TIP</strong>: <code>CustomWriter</code> will print trash if we feed unordered <a href="https://docs.rs/cucumber/*/cucumber/event/enum.Cucumber.html"><code>event::Cucumber</code></a>s into it. Though, we shouldn't care about order normalization in our implementations. Instead, we may just wrap <code>CustomWriter</code> into <a href="https://docs.rs/cucumber/*/cucumber/writer/struct.Normalize.html"><code>writer::Normalize</code></a>, which will do that for us.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::{convert::Infallible, path::PathBuf, time::Duration};
</span><span class="boring">
</span><span class="boring">use async_trait::async_trait;
</span><span class="boring">use cucumber::{
</span><span class="boring">    cli, event, gherkin, given, parser, then, when, Event, World, WorldInit,
</span><span class="boring">    WriterExt as _,
</span><span class="boring">};
</span><span class="boring">use futures::{future, stream};
</span><span class="boring">use tokio::time::sleep;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, Default)]
</span><span class="boring">struct Animal {
</span><span class="boring">    pub hungry: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal {
</span><span class="boring">    fn feed(&amp;mut self) {
</span><span class="boring">        self.hungry = false;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, WorldInit)]
</span><span class="boring">pub struct AnimalWorld {
</span><span class="boring">    cat: Animal,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl World for AnimalWorld {
</span><span class="boring">    type Error = Infallible;
</span><span class="boring">
</span><span class="boring">    async fn new() -&gt; Result&lt;Self, Infallible&gt; {
</span><span class="boring">        Ok(Self {
</span><span class="boring">            cat: Animal::default(),
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[given(regex = r&quot;^a (hungry|satiated) cat$&quot;)]
</span><span class="boring">async fn hungry_cat(world: &amp;mut AnimalWorld, state: String) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    match state.as_str() {
</span><span class="boring">        &quot;hungry&quot; =&gt; world.cat.hungry = true,
</span><span class="boring">        &quot;satiated&quot; =&gt; world.cat.hungry = false,
</span><span class="boring">        _ =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[when(&quot;I feed the cat&quot;)]
</span><span class="boring">async fn feed_cat(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    world.cat.feed();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[then(&quot;the cat is not hungry&quot;)]
</span><span class="boring">async fn cat_is_fed(world: &amp;mut AnimalWorld) {
</span><span class="boring">    sleep(Duration::from_secs(2)).await;
</span><span class="boring">
</span><span class="boring">    assert!(!world.cat.hungry);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomParser;
</span><span class="boring">
</span><span class="boring">impl&lt;I&gt; cucumber::Parser&lt;I&gt; for CustomParser {
</span><span class="boring">    type Cli = cli::Empty;
</span><span class="boring">    type Output = stream::Once&lt;future::Ready&lt;parser::Result&lt;gherkin::Feature&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn parse(self, _: I, _: Self::Cli) -&gt; Self::Output {
</span><span class="boring">        let keyword = &quot;Feature&quot;;
</span><span class="boring">        let name = &quot;Animal feature&quot;;
</span><span class="boring">        stream::once(future::ok(gherkin::Feature {
</span><span class="boring">            keyword: keyword.into(),
</span><span class="boring">            name: name.into(),
</span><span class="boring">            description: None,
</span><span class="boring">            background: None,
</span><span class="boring">            scenarios: vec![gherkin::Scenario {
</span><span class="boring">                keyword: &quot;Scenario&quot;.into(),
</span><span class="boring">                name: &quot;If we feed a hungry cat it won't be hungry&quot;.into(),
</span><span class="boring">                steps: vec![
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Given&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Given,
</span><span class="boring">                        value: &quot;a hungry cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 18 },
</span><span class="boring">                        position: gherkin::LineCol { line: 3, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;When&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::When,
</span><span class="boring">                        value: &quot;I feed the cat&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 19 },
</span><span class="boring">                        position: gherkin::LineCol { line: 4, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                    gherkin::Step {
</span><span class="boring">                        keyword: &quot;Then&quot;.into(),
</span><span class="boring">                        ty: gherkin::StepType::Then,
</span><span class="boring">                        value: &quot;the cat is not hungry&quot;.into(),
</span><span class="boring">                        docstring: None,
</span><span class="boring">                        table: None,
</span><span class="boring">                        span: gherkin::Span { start: 5, end: 26 },
</span><span class="boring">                        position: gherkin::LineCol { line: 5, col: 5 },
</span><span class="boring">                    },
</span><span class="boring">                ],
</span><span class="boring">                examples: vec![],
</span><span class="boring">                tags: vec![],
</span><span class="boring">                span: gherkin::Span { start: 3, end: 52 },
</span><span class="boring">                position: gherkin::LineCol { line: 2, col: 3 },
</span><span class="boring">            }],
</span><span class="boring">            rules: vec![],
</span><span class="boring">            tags: vec![],
</span><span class="boring">            span: gherkin::Span { start: 1, end: 23 },
</span><span class="boring">            position: gherkin::LineCol { line: 1, col: 1 },
</span><span class="boring">            path: Some(PathBuf::from(file!())),
</span><span class="boring">        }))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomWriter;
</span><span class="boring">
</span><span class="boring">#[async_trait(?Send)]
</span><span class="boring">impl&lt;W: 'static&gt; cucumber::Writer&lt;W&gt; for CustomWriter {
</span><span class="boring">    type Cli = cli::Empty; // we provide no CLI options
</span><span class="boring">
</span><span class="boring">    async fn handle_event(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        ev: parser::Result&lt;Event&lt;event::Cucumber&lt;W&gt;&gt;&gt;,
</span><span class="boring">        _: &amp;Self::Cli,
</span><span class="boring">    ) {
</span><span class="boring">        match ev {
</span><span class="boring">            Ok(Event { value, .. }) =&gt; match value {
</span><span class="boring">                event::Cucumber::Feature(feature, ev) =&gt; match ev {
</span><span class="boring">                    event::Feature::Started =&gt; {
</span><span class="boring">                        println!(&quot;{}: {}&quot;, feature.keyword, feature.name)
</span><span class="boring">                    }
</span><span class="boring">                    event::Feature::Scenario(scenario, ev) =&gt; match ev {
</span><span class="boring">                        event::Scenario::Started =&gt; {
</span><span class="boring">                            println!(&quot;{}: {}&quot;, scenario.keyword, scenario.name)
</span><span class="boring">                        }
</span><span class="boring">                        event::Scenario::Step(step, ev) =&gt; match ev {
</span><span class="boring">                            event::Step::Started =&gt; {
</span><span class="boring">                                print!(&quot;{} {}...&quot;, step.keyword, step.value)
</span><span class="boring">                            }
</span><span class="boring">                            event::Step::Passed(_) =&gt; println!(&quot;ok&quot;),
</span><span class="boring">                            event::Step::Skipped =&gt; println!(&quot;skip&quot;),
</span><span class="boring">                            event::Step::Failed(_, _, err) =&gt; {
</span><span class="boring">                                println!(&quot;failed: {err}&quot;, )
</span><span class="boring">                            }
</span><span class="boring">                        },
</span><span class="boring">                        _ =&gt; {}
</span><span class="boring">                    },
</span><span class="boring">                    _ =&gt; {}
</span><span class="boring">                },
</span><span class="boring">                _ =&gt; {}
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; println!(&quot;Error: {e}&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() {
    AnimalWorld::cucumber::&lt;&amp;str&gt;() // aiding type inference for `CustomParser`
        .with_parser(CustomParser)
        .with_writer(CustomWriter.normalized()) // wrapping into `writer::Normalize`,
        .run(&quot;/tests/features/book&quot;)            // so it works OK with the default
        .await;                                 // concurrent `Runner`
}
</code></pre></pre>
<p><img src="architecture/../rec/architecture_writer_normalized.gif" alt="record" /></p>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://docs.rs/cucumber/*/cucumber/writer/index.html"><code>Writer</code></a>s are easily pipelined. See <a href="https://docs.rs/cucumber/*/cucumber/trait.WriterExt.html"><code>WriterExt</code></a> trait and <a href="https://docs.rs/cucumber/*/cucumber/writer/index.html"><code>writer</code></a> module for more <a href="https://docs.rs/cucumber/*/cucumber/writer/index.html"><code>Writer</code></a> machinery &quot;included batteries&quot;.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
